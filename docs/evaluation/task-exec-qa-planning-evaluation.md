# `/task-exec` カスタムプロンプト QA計画可能性評価レポート

**評価日**: 2025-11-22
**評価者**: Claude Code (Sonnet 4.5)
**評価対象**: `.claude/commands/task-exec.md`

---

## エグゼクティブサマリー

### 評価の目的
`/task-exec` カスタムプロンプトにおいて、**task単位のQAで実行すべきことを計画可能な状態になっているか**を批判的かつ客観的に評価する。

### 主要な発見事項
1. ✅ **自動テスト項目は明確に定義されている**（5項目の必須チェック）
2. ✅ **テスト評価基準は明確**（SUCCESS/FAILURE/PARTIAL）
3. ❌ **受け入れ条件の所在が不明確**（最重要課題）
4. ❌ **requirements.md/design.mdの構造が未定義**
5. ❌ **GitHubIssueのタスクグループ形式が未定義**
6. ⚠️ **レビューガイドラインドキュメントが未作成**

### 総合評価
**QA計画可能性スコア: 60/100**

- **計画可能な部分**: 自動テスト（pnpm test/lint/build/typecheck）の実行とその判定
- **計画不能な部分**: 受け入れ条件に基づく動作確認テストの設計と実施

---

## 1. 調査結果の概要

### 1.1 `/task-exec`コマンドの構造

**目的**: GitHub Issueから着手可能なタスクグループを自動選定し、実装から完了まで一連のプロセスを管理する。

**実行フロー**:
```
入力（Issue番号 + タスクグループ番号）
  ↓
ステップ1: タスク選定（task-starter）
  ↓
ステップ2: 品質保証ループ（QA合格まで繰り返し）
  ├─ 2.1 実装（task-executer）
  ├─ 2.2 レビュー（task-reviewer） → 問題あり → 2.1へ戻る
  └─ 2.3 品質保証（task-qa） → 問題あり → 2.1へ戻る
  ↓
ステップ3: 完了処理（task-finisher）
  ↓
【完了】または【追加修正対応】（task-modification-analyzer）
```

### 1.2 使用されるサブエージェント

| エージェント | モデル | 役割 | 主要な出力 |
|------------|--------|------|-----------|
| task-starter | Haiku | タスク選定 | Issue更新（着手中マーク） |
| task-executer | Sonnet | 実装 | コード、テスト、modifications/phaseN/X-Y.md |
| task-reviewer | Sonnet | レビュー | PASS/MINOR/MAJOR判定 |
| **task-qa** | **Sonnet** | **品質保証** | **qa-tests/phaseN/X-Y.md、SUCCESS/FAILURE/PARTIAL判定** |
| task-finisher | Sonnet | 完了処理 | Issue更新（完了チェック） |
| task-modification-analyzer | Sonnet | 追加修正分析 | 修正方針提案 |

### 1.3 QA関連の指示内容（task-qaの詳細）

#### 必須自動テスト項目（5項目）
1. ✅ `pnpm test` - ユニットテスト
2. ✅ `pnpm test:e2e` - E2Eテスト（該当する場合）
3. ✅ `pnpm lint` - Biome lintチェック
4. ✅ `pnpm build` - ビルドチェック
5. ✅ `pnpm typecheck` - TypeScript型チェック

**判定**: 1つでも失敗したら即座に**FAILURE**と判定し、task-executerに差し戻す。

#### 動作確認の実施方法
- **画面テスト**: Playwright MCP使用
- **APIテスト**: curlコマンド使用
- **スクリプトテスト**: 直接実行

#### テスト結果の評価基準
- **SUCCESS**: すべての受け入れ条件を満たす
- **FAILURE**: 受け入れ条件を満たさない、テスト失敗、lintエラー、ビルドエラー、型エラー、動作エラー
- **PARTIAL**: 動作には影響しない軽微な問題のみ（ただし、テスト失敗/lintエラー/ビルドエラー/型エラーは絶対にPARTIALにできない）

#### 禁止事項
❌ **構造確認のみのテスト**（ファイル存在確認、文字列含有確認、import確認など）は作成禁止

#### テスト項目作成方針
✅ **振る舞いを検証する**シナリオ作成（Given/When/Then形式）
✅ 観測可能なアウトプット（API レスポンス、DB 状態、画面表示）を検証
✅ 正常系・異常系・境界ケースを含める

---

## 2. QA計画可能性の評価

### 2.1 計画可能な要素（明確に定義されている）

#### ✅ 自動テストの実行と判定
**評価**: **完全に計画可能**

- **根拠**:
  - 5つの必須自動テスト項目が明確に定義されている
  - 各テストコマンドが具体的（`pnpm test`, `pnpm lint`, etc.）
  - 判定基準が明確（1つでも失敗したらFAILURE）

- **QAエージェントが実行できること**:
  ```bash
  pnpm test          # ユニットテスト実行
  pnpm test:e2e      # E2Eテスト実行
  pnpm lint          # Lintチェック
  pnpm build         # ビルドチェック
  pnpm typecheck     # 型チェック
  ```

#### ✅ テスト評価基準
**評価**: **明確に定義されている**

- **根拠**:
  - SUCCESS/FAILURE/PARTIALの3段階評価
  - 各評価の判定基準が具体的に記載
  - FAILUREと判定すべき条件が明確（テスト失敗、lintエラー、ビルドエラー、型エラー、動作エラー）
  - PARTIALにできない条件が明確に禁止事項として記載

#### ✅ 禁止事項
**評価**: **明確に定義されている**

- **根拠**:
  - 構造確認のみのテストが禁止されていることが明示
  - 具体例が記載（ファイル存在確認、文字列含有確認、import確認）
  - 理由も説明（ビジネスロジックやデータフローを検証していない）

#### ✅ テスト実行方法
**評価**: **明確に定義されている**

- **根拠**:
  - 画面テスト（Playwright MCP）、APIテスト（curl）、スクリプトテストの3種類が明示
  - 各テスト方法の具体的なコード例が記載

### 2.2 計画不能な要素（不明確・不十分）

#### ❌ 受け入れ条件の所在と形式
**評価**: **計画不能の最大要因**

- **問題**:
  - プロンプトで「受け入れ条件に基づく徹底的なテスト」と記載されているが、受け入れ条件がどこに記載されているかが不明
  - QAエージェントが受け入れ条件を参照する方法が定義されていない

- **影響**:
  - **QAエージェントが何をテストすべきか判断できない**
  - 動作確認のテストシナリオを作成できない
  - 「受け入れ条件を満たす」かどうかを判定できない

- **推測される所在**:
  1. `requirements.md` に受け入れ基準が含まれている可能性
  2. `design.md` に受け入れ条件が含まれている可能性
  3. GitHub Issueのタスクグループに完了条件として含まれている可能性

  → **しかし、これらのいずれも形式が未定義**

#### ❌ requirements.md / design.md の構造定義
**評価**: **計画の重要な障害**

- **問題**:
  - これらのドキュメントがどのような構造で記載されているかが不明
  - 受け入れ条件がどのセクションに記載されているかが不明
  - QAエージェントがドキュメントから必要情報を抽出する方法が不明

- **影響**:
  - QAエージェントがドキュメントを読んでも、どこに受け入れ条件が記載されているか判断できない
  - テストシナリオを作成するための情報が取得できない

- **参照ドキュメント**:
  - `docs/steering/acceptance-criteria-and-qa-guide.md` に受け入れ基準の原則は記載されているが、実際の仕様書（requirements.md/design.md）のテンプレートは記載されていない

#### ❌ GitHub Issueのタスクグループ形式
**評価**: **計画の障害**

- **問題**:
  - タスクグループに「完了条件」が含まれると記載されているが、その記載形式が不明
  - Phase、依存関係、完了条件の記載方法が定義されていない
  - task-starterがどのようにこれらの情報を抽出するかが不明確

- **影響**:
  - QAエージェントがGitHub Issueから受け入れ条件を取得できない可能性
  - task-starterが正しくタスクを選定できない可能性

#### ⚠️ QA仕様書の初期状態
**評価**: **軽度の不明確さ**

- **問題**:
  - `qa-tests/phaseN/X-Y.md` が事前に作成されているのか、QAエージェントが作成するのか不明
  - プロンプトで「追記」と記載されているが、初期作成についての指示がない

- **影響**:
  - QAエージェントの作業範囲が不明確
  - 初回実行時にファイルが存在しない場合の対応が不明

- **推測**:
  - `spec-qa-generator` エージェントが事前にQA仕様書を作成する可能性があるが、`/task-exec` プロンプト内では明示されていない

#### ⚠️ レビューガイドラインドキュメントの欠如
**評価**: **計画への影響は限定的**

- **問題**:
  - `docs/steering/review/implementation-review-guidelines.md` が「参照予定だが未作成」と明記

- **影響**:
  - task-reviewerの判断基準が不完全になる可能性
  - ただし、プロンプト内に主要なレビュー観点は記載されているため、QA計画への直接的な影響は小さい

#### ⚠️ テスト項目の具体例不足
**評価**: **軽度の不足**

- **問題**:
  - 「振る舞いを検証する」という抽象的な指示のみ
  - プロンプト内に具体的なテスト項目例が少ない

- **影響**:
  - QAエージェントが適切なテスト項目を作成できない可能性
  - ただし、`docs/steering/acceptance-criteria-and-qa-guide.md` に具体例が記載されているため、影響は限定的

---

## 3. 計画不能の原因分析（根拠が強い順）

### 原因1: 受け入れ条件の所在が不明確
**根拠の強さ**: ⭐⭐⭐⭐⭐（最強）

#### 問題の詳細
- プロンプト内で「受け入れ条件に基づく徹底的なテスト」と17回以上言及されているが、受け入れ条件の所在が一切明示されていない
- QAエージェント（task-qa）が受け入れ条件をどこから取得すべきかが不明

#### 根拠
1. **プロンプトの記載**:
   - 「受け入れ条件に基づく動作確認」（task-qaの役割）
   - 「受け入れ基準とのトレーサビリティ確保」（QAテスト項目作成方針）
   - 「関連 AC: [受け入れ基準の参照]」（QA仕様書テンプレート）

   → **しかし、「受け入れ基準」がどこにあるかは記載されていない**

2. **推測される所在**:
   - `requirements.md` に含まれる可能性
   - `design.md` に含まれる可能性
   - GitHub Issueのタスクグループに含まれる可能性

   → **いずれも形式が未定義のため、QAエージェントが抽出できない**

3. **影響の大きさ**:
   - 自動テスト（pnpm test/lint/build）は実行可能
   - **しかし、動作確認のテストシナリオを作成できない** ← これがQAの中核業務
   - 「SUCCESS」判定ができない（「すべての受け入れ条件を満たす」かどうかを判断できない）

#### 計画不能の具体例

QAエージェントに以下のタスクが与えられた場合:

**タスク**: 「1.1 - ユーザー認証機能の実装」

**QAエージェントが実行できること**:
```bash
# 自動テストの実行
pnpm test          # ✅ 実行可能
pnpm lint          # ✅ 実行可能
pnpm build         # ✅ 実行可能
```

**QAエージェントが実行できないこと**:
```
# 動作確認のテストシナリオ作成
- ❌ どのような認証方式をテストすべきか？（JWT? OAuth? Session?）
- ❌ どのようなユーザーロールをテストすべきか？（Admin? User? Guest?）
- ❌ どのような認証フローをテストすべきか？（ログイン? ログアウト? パスワードリセット?）
- ❌ 異常系はどこまでテストすべきか？（不正なトークン? 期限切れトークン?）
```

→ **受け入れ条件が不明なため、テストシナリオを設計できない**

#### 推奨される解決策

1. **即効性の高い対策**: requirements.mdのテンプレート作成
   ```markdown
   ## 受け入れ基準（Acceptance Criteria）

   ### AC1: [受け入れ基準1のタイトル]
   - Given: [前提条件]
   - When: [実行する操作]
   - Then: [期待される結果]

   ### AC2: [受け入れ基準2のタイトル]
   ...
   ```

2. **プロンプトへの追加**:
   ```markdown
   ## 受け入れ条件の参照方法

   1. `requirements.md` の「受け入れ基準（Acceptance Criteria）」セクションを参照
   2. 各ACに対して、Given/When/Thenに基づくテストシナリオを作成
   3. すべてのACが満たされた場合のみ、SUCCESS判定
   ```

---

### 原因2: requirements.md / design.md の構造が未定義
**根拠の強さ**: ⭐⭐⭐⭐（強）

#### 問題の詳細
- プロンプト内でこれらのドキュメントを「要件定義・設計書に基づいた実装」と参照しているが、ドキュメントの構造が未定義
- QAエージェントがドキュメントから必要情報を抽出する方法が不明

#### 根拠
1. **プロンプトの記載**:
   - task-executer: 「要件・設計の確認（`requirements.md`、`design.md`）」
   - task-reviewer: 「要件定義・設計書との整合性（最優先）」
   - task-qa: （暗黙的に参照が期待される）

   → **しかし、これらのドキュメントの構造は定義されていない**

2. **参照ドキュメントの不足**:
   - `docs/steering/acceptance-criteria-and-qa-guide.md` には受け入れ基準の原則は記載されているが、requirements.md/design.mdのテンプレートは記載されていない

3. **影響の大きさ**:
   - QAエージェントがドキュメントを読んでも、どこに受け入れ条件が記載されているか判断できない
   - 「背景/価値」「関連 AC」などのQA仕様書テンプレートの項目を埋められない

#### 計画不能の具体例

QAエージェントが `requirements.md` を読んだ場合:

**現状**:
```markdown
# ユーザー認証機能

ユーザーがログインできるようにする。
認証にはJWTを使用する。
```

**QAエージェントの疑問**:
- ❌ これが受け入れ条件なのか、単なる概要なのか判断できない
- ❌ テストすべき具体的な動作が不明（どのような入力値でどのような出力を期待するのか）
- ❌ 異常系の扱いが不明

**期待される構造**:
```markdown
# ユーザー認証機能

## 概要
ユーザーがメールアドレスとパスワードでログインできるようにする。

## 受け入れ基準（Acceptance Criteria）

### AC1: 正常なログイン
- Given: 登録済みユーザーが存在する
- When: 正しいメールアドレスとパスワードでログイン
- Then: JWTトークンが発行され、ダッシュボードにリダイレクトされる

### AC2: 不正なパスワード
- Given: 登録済みユーザーが存在する
- When: 正しいメールアドレスだが間違ったパスワードでログイン
- Then: エラーメッセージ「パスワードが正しくありません」が表示される
```

→ **構造が明確であれば、QAエージェントがテストシナリオを設計可能**

#### 推奨される解決策

1. **requirements.md テンプレートの作成**:
   ```markdown
   # [機能名]

   ## 概要
   [機能の概要]

   ## 背景・価値
   [なぜこの機能が必要か]

   ## 受け入れ基準（Acceptance Criteria）

   ### AC1: [受け入れ基準1のタイトル]
   - Given: [前提条件]
   - When: [実行する操作]
   - Then: [期待される結果]

   ### AC2: [受け入れ基準2のタイトル]
   ...

   ## 非機能要件
   - パフォーマンス: [基準]
   - セキュリティ: [基準]
   ```

2. **design.md テンプレートの作成**:
   ```markdown
   # [機能名] 設計書

   ## アーキテクチャ
   [システム構成図]

   ## データモデル
   [データベーススキーマ]

   ## API仕様
   [エンドポイント、リクエスト/レスポンス]

   ## 技術選定
   [使用する技術とその理由]
   ```

3. **プロンプトへの追加**:
   ```markdown
   ## 要件・設計ドキュメントの参照方法

   1. `requirements.md` の「受け入れ基準（Acceptance Criteria）」セクションからACを抽出
   2. `design.md` の「API仕様」「データモデル」セクションから技術詳細を確認
   3. ACに基づいてテストシナリオを作成
   ```

---

### 原因3: GitHub Issueのタスクグループ形式が未定義
**根拠の強さ**: ⭐⭐⭐⭐（強）

#### 問題の詳細
- プロンプトでGitHub Issueに「Phase」「依存関係」「完了条件」が含まれると記載されているが、その記載形式が定義されていない
- task-starterがどのようにこれらの情報を抽出するかが不明確

#### 根拠
1. **プロンプトの記載**:
   - task-starter: 「タスク構造の抽出（Phase、依存関係、完了条件）」
   - task-starter完了報告: 「完了条件: ...」

   → **しかし、Issueのどこに完了条件が記載されるかは不明**

2. **推測される形式**:
   - Markdown形式のチェックリスト？
   - YAMLフロントマター？
   - 特定のセクション？

   → **いずれも明示されていない**

3. **影響の大きさ**:
   - task-starterがタスクを正しく抽出できない可能性
   - QAエージェントがIssueから受け入れ条件を取得できない可能性

#### 計画不能の具体例

GitHub Issueの例（形式が不明）:

**パターンA**（チェックリスト形式？）:
```markdown
## Phase 1: 基盤構築

- [ ] 1.1 Prismaスキーマ定義
  - 依存: なし
  - 完了条件: スキーマが正しくマイグレーションされ、クライアントが生成される

- [ ] 1.2 認証APIの実装
  - 依存: 1.1
  - 完了条件: ログイン/ログアウトAPIが動作し、JWTが発行される
```

**パターンB**（YAMLフロントマター？）:
```yaml
---
tasks:
  - id: 1.1
    title: Prismaスキーマ定義
    phase: 1
    dependencies: []
    acceptance_criteria:
      - スキーマが正しくマイグレーションされる
      - クライアントが生成される
---
```

**パターンC**（構造化されたセクション？）:
```markdown
## タスク1.1: Prismaスキーマ定義

### 依存関係
なし

### 完了条件
- スキーマが正しくマイグレーションされる
- クライアントが生成される

### 受け入れ基準
- AC1: マイグレーションが成功する
- AC2: Prismaクライアントが生成される
```

→ **形式が不明なため、task-starterが抽出できない可能性**
→ **QAエージェントが受け入れ条件を取得できない可能性**

#### 推奨される解決策

1. **GitHub Issue テンプレートの作成**:
   ```markdown
   # [機能名]

   ## 概要
   [機能の概要]

   ## タスク一覧

   ### Phase 1: [フェーズ名]

   #### 1.1 [タスク名]
   - **依存関係**: なし / 1.X, 2.Y
   - **完了条件**:
     - [完了条件1]
     - [完了条件2]
   - **受け入れ基準**:
     - AC1: [Given/When/Then]
     - AC2: [Given/When/Then]
   - **関連ドキュメント**: `docs/specs/tasks/YYYYMMDD-[task-name]/requirements.md`
   - [ ] **1.1 [タスク名]**

   #### 1.2 [タスク名]
   ...
   ```

2. **プロンプトへの追加**:
   ```markdown
   ## GitHub Issueの形式

   - タスクグループは「#### X.Y [タスク名]」形式で記載
   - 各タスクグループには以下の情報が含まれる:
     - 依存関係: `- **依存関係**: 1.1, 1.2`
     - 完了条件: `- **完了条件**: [条件のリスト]`
     - 受け入れ基準: `- **受け入れ基準**: AC1: ...`
   - チェックボックス: `- [ ] **X.Y [タスク名]**`
   ```

---

### 原因4: QA仕様書の初期状態が不明
**根拠の強さ**: ⭐⭐⭐（中）

#### 問題の詳細
- `qa-tests/phaseN/X-Y.md` が事前に作成されているのか、QAエージェントが作成するのか不明
- プロンプトで「追記」と記載されているが、初期作成についての指示がない

#### 根拠
1. **プロンプトの記載**:
   - task-qa: 「QA仕様書への結果記録」
   - task-qa: 「`qa-tests/phaseN/X-Y.md` に結果を追記しました」

   → **「追記」とあるが、初期作成については不明**

2. **推測**:
   - `spec-qa-generator` エージェントが事前にQA仕様書を作成する可能性
   - しかし、`/task-exec` プロンプト内では明示されていない

3. **影響の大きさ**:
   - 初回実行時にファイルが存在しない場合、QAエージェントがエラーになる可能性
   - ただし、QAエージェントが新規作成することも可能なため、影響は限定的

#### 計画不能の具体例

**シナリオ1**: QA仕様書が事前に存在する場合
```markdown
# qa-tests/phase1/1-1.md（事前作成済み）

## 機能名: Prismaスキーマ定義とマイグレーション実行
- 背景/価値: データベーススキーマを定義し、アプリケーションで使用可能にする
- 関連 AC: requirements.md の AC1, AC2
- テスト範囲: Integration

- シナリオ:
  1. Prismaクライアント生成
     - 前提: スキーマファイルが存在する
     - 操作: `pnpm db:generate` を実行
     - 期待結果: `node_modules/.prisma/client` が生成される
     - ログ/メトリクス確認方法: ファイルシステム確認

### 実施結果（最終更新: 2025-11-22）
（QAエージェントが追記）
```

**シナリオ2**: QA仕様書が存在しない場合
```
# qa-tests/phase1/1-1.md（存在しない）

→ QAエージェントが新規作成？
→ エラー？
→ 不明
```

#### 推奨される解決策

1. **プロンプトへの明示的な指示追加**:
   ```markdown
   ## QA仕様書の作成・更新

   1. `qa-tests/phaseN/X-Y.md` が存在しない場合、新規作成する
   2. 存在する場合、「実施結果」セクションのみを更新する
   3. テンプレート:
      ```markdown
      ## 機能名: [タスク名]
      - 背景/価値: [requirements.mdから抽出]
      - 関連 AC: [受け入れ基準の参照]
      - テスト範囲: [Integration/E2E]

      - シナリオ:
        1. [シナリオ1]
           ...

      ### 実施結果（最終更新: YYYY-MM-DD）
      ...
      ```
   ```

2. **spec-qa-generatorとの連携明示**:
   ```markdown
   ## QA仕様書の事前作成（オプション）

   - `/spec-qa-generator` コマンドで事前にQA仕様書を作成可能
   - task-qaは、事前作成されたQA仕様書がある場合はそれを使用
   - 存在しない場合は、requirements.mdから受け入れ基準を抽出してQA仕様書を新規作成
   ```

---

### 原因5: レビューガイドラインドキュメントの欠如
**根拠の強さ**: ⭐⭐⭐（中）

#### 問題の詳細
- `docs/steering/review/implementation-review-guidelines.md` が「参照予定だが未作成」と明記されている
- task-reviewerの判断基準が不完全になる可能性

#### 根拠
1. **プロンプトの記載**:
   - task-reviewer: 「参照ドキュメント: `docs/steering/review/implementation-review-guidelines.md`（参照予定だが未作成）」

   → **明示的に未作成と記載**

2. **影響の大きさ**:
   - task-reviewerの判断基準が不完全になる可能性
   - ただし、プロンプト内に主要なレビュー観点（要件適合性、仮実装チェック、必須チェック項目）は記載されているため、QA計画への直接的な影響は小さい

3. **QA計画への影響**:
   - レビューフェーズでの判定が不正確になる可能性
   - その結果、QAフェーズに不適切な実装が流れてくる可能性

   → **間接的な影響のみ**

#### 推奨される解決策

1. **レビューガイドラインの作成**:
   ```markdown
   # 実装レビューガイドライン

   ## レビュー観点

   ### 1. 要件定義・設計書との整合性（最優先）
   - requirements.mdの受け入れ基準をすべて満たしているか
   - design.mdの技術仕様に準拠しているか

   ### 2. 仮実装・TODOの検出
   - TODO、FIXME、XXX コメントが残っていないか
   - 仮実装（モックデータ、ハードコード）が残っていないか

   ### 3. 必須チェック項目（すべて成功が必須）
   - [ ] `pnpm test` - ユニットテスト
   - [ ] `pnpm lint` - Lintチェック
   - [ ] `pnpm build` - ビルドチェック
   - [ ] `pnpm typecheck` - 型チェック
   - [ ] 相対パス検出チェック

   ### 4. コード品質チェック
   - コーディング規約準拠（docs/coding-standards.mdc）
   - 適切なエラーハンドリング
   - セキュリティベストプラクティス準拠

   ## 判定基準

   ### PASS
   - すべての要件を満たす
   - 必須チェック項目がすべて成功
   - 仮実装・TODOなし

   ### MINOR
   - 軽微な問題のみ（後続タスクで対応予定）
   - **ただし、以下は絶対にMINORにできない**:
     - ユニットテスト失敗
     - Lint/ビルド/型エラー
     - 仮実装（TODO/FIXME）
     - 相対パスの使用

   ### MAJOR
   - 重大な問題あり
   - executerフェーズに差し戻し
   ```

2. **プロンプトの更新**:
   ```markdown
   参照ドキュメント: `docs/steering/review/implementation-review-guidelines.md`
   ```
   （「参照予定だが未作成」を削除）

---

### 原因6: テスト項目の具体例不足
**根拠の強さ**: ⭐⭐（弱）

#### 問題の詳細
- 「振る舞いを検証する」という抽象的な指示のみ
- プロンプト内に具体的なテスト項目例が少ない

#### 根拠
1. **プロンプトの記載**:
   - task-qa: 「振る舞いを検証するシナリオ作成（Given/When/Then形式）」
   - task-qa: 「観測可能なアウトプット（API レスポンス、DB 状態、画面表示）を検証」

   → **原則は記載されているが、具体例が少ない**

2. **参照ドキュメント**:
   - `docs/steering/acceptance-criteria-and-qa-guide.md` には具体例が記載されている
   - Repository、UseCase、API、バッチ、フロントエンドの各レベルでの例が提供されている

   → **参照ドキュメントが存在するため、影響は限定的**

3. **影響の大きさ**:
   - QAエージェントが適切なテスト項目を作成できない可能性
   - ただし、参照ドキュメントが存在するため、致命的ではない

#### 推奨される解決策

1. **プロンプトへの具体例追加**（オプション）:
   ```markdown
   ## テスト項目の具体例

   ### 画面テスト（Playwright）
   ```javascript
   // ログイン画面のテスト
   await page.goto('/login');
   await page.fill('#email', 'test@example.com');
   await page.fill('#password', 'password123');
   await page.click('button[type="submit"]');
   await expect(page).toHaveURL('/dashboard');
   ```

   ### APIテスト（curl）
   ```bash
   # 認証APIのテスト
   curl -X POST http://localhost:3000/api/auth/login \
     -H "Content-Type: application/json" \
     -d '{"email":"test@example.com","password":"password123"}'

   # 期待結果: {"token":"...", "user":{...}}
   ```

   ### データベーステスト
   ```bash
   # Prismaスキーマのテスト
   pnpm db:push
   pnpm db:generate

   # 期待結果: Prismaクライアントが生成される
   ```
   ```

2. **参照ドキュメントへの明示的な誘導**:
   ```markdown
   ## テスト項目作成の参考

   詳細な具体例は `docs/steering/acceptance-criteria-and-qa-guide.md` を参照してください。
   以下のレベル別の例が記載されています：
   - Repository層のテスト例
   - UseCase層のテスト例
   - API層のテスト例
   - バッチ処理のテスト例
   - フロントエンドのテスト例
   ```

---

## 4. 推奨事項（優先度順）

### 優先度1（最重要・即対応）: 受け入れ条件の明確化

#### 対応内容
1. **requirements.md テンプレートの作成**
   - 「受け入れ基準（Acceptance Criteria）」セクションを必須化
   - Given/When/Then 形式での記載を標準化
   - 正常系・異常系・境界ケースを含める

2. **プロンプトへの追加**
   - 受け入れ条件の参照方法を明示
   - QAエージェントが受け入れ条件を抽出する手順を記載

3. **GitHub Issue テンプレートの更新**
   - 各タスクグループに「受け入れ基準」セクションを追加
   - requirements.mdへのリンクを含める

#### 期待される効果
- **QA計画可能性が 60点 → 85点 に向上**
- QAエージェントが動作確認のテストシナリオを設計可能になる
- 「SUCCESS」判定の基準が明確になる

---

### 優先度2（重要・早期対応）: ドキュメント構造の標準化

#### 対応内容
1. **requirements.md テンプレートの詳細化**
   ```markdown
   # [機能名]

   ## 概要
   [1-2文で機能の概要を説明]

   ## 背景・価値
   [なぜこの機能が必要か、どのような価値を提供するか]

   ## 受け入れ基準（Acceptance Criteria）

   ### AC1: [受け入れ基準1のタイトル]
   - **Given**: [前提条件]
   - **When**: [実行する操作]
   - **Then**: [期待される結果]
   - **テストレベル**: Unit / Integration / E2E

   ### AC2: [受け入れ基準2のタイトル]
   ...

   ## 非機能要件
   - **パフォーマンス**: [基準]
   - **セキュリティ**: [基準]
   - **アクセシビリティ**: [基準]

   ## 制約事項
   [技術的制約、ビジネス制約]

   ## 参考資料
   [関連ドキュメント、外部リソース]
   ```

2. **design.md テンプレートの詳細化**
   ```markdown
   # [機能名] 設計書

   ## アーキテクチャ
   [システム構成図、コンポーネント構成]

   ## データモデル
   [データベーススキーマ、エンティティ図]

   ## API仕様
   ### [エンドポイント名]
   - **メソッド**: GET / POST / PUT / DELETE
   - **パス**: /api/...
   - **リクエスト**: [スキーマ]
   - **レスポンス**: [スキーマ]
   - **エラー**: [エラーコード一覧]

   ## 技術選定
   [使用する技術とその理由]

   ## セキュリティ考慮事項
   [認証、認可、データ保護]

   ## パフォーマンス考慮事項
   [最適化戦略、キャッシュ戦略]
   ```

3. **プロンプトへの追加**
   ```markdown
   ## ドキュメント構造

   ### requirements.md
   - **受け入れ基準（Acceptance Criteria）**: Given/When/Then形式で記載
   - QAエージェントはこのセクションから受け入れ基準を抽出

   ### design.md
   - **API仕様**: エンドポイント、リクエスト/レスポンス
   - **データモデル**: データベーススキーマ
   - QAエージェントは技術詳細の確認に使用
   ```

#### 期待される効果
- **QA計画可能性が 85点 → 90点 に向上**
- QAエージェントがドキュメントから必要情報を確実に抽出可能になる
- 実装エージェント（task-executer）とレビューエージェント（task-reviewer）も恩恵を受ける

---

### 優先度3（中程度・計画的対応）: GitHub Issue 形式の標準化

#### 対応内容
1. **GitHub Issue テンプレートの作成**
   ```markdown
   # [機能名]

   ## 概要
   [機能の概要]

   ## タスク一覧

   ### Phase 1: [フェーズ名]

   #### 1.1 [タスク名]
   - **依存関係**: なし / 1.X, 2.Y
   - **完了条件**:
     - [完了条件1]
     - [完了条件2]
   - **受け入れ基準**:
     - AC1: Given [前提] When [操作] Then [結果]
     - AC2: Given [前提] When [操作] Then [結果]
   - **関連ドキュメント**:
     - 要件: `docs/specs/tasks/YYYYMMDD-[task-name]/requirements.md`
     - 設計: `docs/specs/tasks/YYYYMMDD-[task-name]/design.md`
   - **見積もり**: [小/中/大]
   - [ ] **1.1 [タスク名]**

   #### 1.2 [タスク名]
   ...

   ### Phase 2: [フェーズ名]
   ...
   ```

2. **プロンプトへの追加**
   ```markdown
   ## GitHub Issue の形式

   ### タスクグループの記載形式
   - 各タスクグループは「#### X.Y [タスク名]」形式で記載
   - 必須項目:
     - **依存関係**: `- **依存関係**: 1.1, 1.2` または `なし`
     - **完了条件**: `- **完了条件**: [条件のリスト]`
     - **受け入れ基準**: `- **受け入れ基準**: AC1: Given/When/Then`
     - **関連ドキュメント**: requirements.md / design.md へのパス
   - チェックボックス: `- [ ] **X.Y [タスク名]**`

   ### task-starterの抽出ロジック
   1. 「#### X.Y」パターンでタスクグループを特定
   2. 「**依存関係**:」行から依存関係を抽出
   3. 「**完了条件**:」行から完了条件を抽出
   4. 「**受け入れ基準**:」行から受け入れ基準を抽出
   5. チェックボックスの状態を確認（`- [ ]` = 未完了、`- [x]` = 完了）
   ```

3. **.github/ISSUE_TEMPLATE/ への配置**
   - `task-implementation.md` として保存
   - GitHub でIssue作成時に自動的に表示

#### 期待される効果
- task-starterが確実にタスク情報を抽出可能になる
- QAエージェントがIssueから受け入れ基準を直接参照可能になる
- チーム全体でタスク管理の一貫性が向上

---

### 優先度4（補完的・計画的対応）: QA仕様書フローの明確化

#### 対応内容
1. **プロンプトへの明示的な指示追加**
   ```markdown
   ## QA仕様書の作成・更新フロー

   ### 初回実行時（qa-tests/phaseN/X-Y.md が存在しない場合）
   1. requirements.md から受け入れ基準を抽出
   2. 各ACに対してテストシナリオを作成
   3. QA仕様書を新規作成
   4. テンプレート:
      ```markdown
      ## 機能名: [タスク名]
      - 背景/価値: [requirements.mdから抽出]
      - 関連 AC: AC1, AC2, AC3
      - テスト範囲: Integration / E2E

      - シナリオ:
        1. [AC1に対応するシナリオ]
           - 前提: [Given]
           - 操作: [When]
           - 期待結果: [Then]
           - ログ/メトリクス確認方法: [確認手段]

        2. [AC2に対応するシナリオ]
           ...

      ### 実施結果（最終更新: YYYY-MM-DD）
      **ステータス: [✅ SUCCESS / ❌ FAILURE / ⚠️ PARTIAL]**
      ...
      ```

   ### 2回目以降の実行時（qa-tests/phaseN/X-Y.md が既に存在する場合）
   1. 既存のQA仕様書を読み込み
   2. 「実施結果」セクションのみを更新
   3. シナリオ部分は保持（変更しない）
   ```

2. **spec-qa-generatorとの連携明示**
   ```markdown
   ## QA仕様書の事前作成（オプション）

   - `/spec-qa-generator` コマンドで事前にQA仕様書を作成可能
   - task-qaは、事前作成されたQA仕様書がある場合はそれを使用
   - 存在しない場合は、requirements.mdから受け入れ基準を抽出してQA仕様書を新規作成
   ```

#### 期待される効果
- QAエージェントの作業範囲が明確になる
- 初回実行時のエラーがなくなる
- spec-qa-generatorとの役割分担が明確になる

---

### 優先度5（補完的・計画的対応）: レビューガイドラインの作成

#### 対応内容
1. **`docs/steering/review/implementation-review-guidelines.md` の作成**
   - 既存のプロンプト内容を体系化
   - コーディング規約（docs/coding-standards.mdc）との整合性確保
   - コードレビューガイドライン（docs/code-review.mdc）との整合性確保

2. **プロンプトの更新**
   - 「参照予定だが未作成」を削除
   - 「参照ドキュメント: `docs/steering/review/implementation-review-guidelines.md`」に変更

#### 期待される効果
- task-reviewerの判断基準が完全になる
- QAフェーズに不適切な実装が流れにくくなる

---

### 優先度6（補完的・任意対応）: テスト項目例の追加

#### 対応内容
1. **プロンプトへの具体例追加**（前述の「原因6」を参照）
2. **参照ドキュメントへの明示的な誘導**

#### 期待される効果
- QAエージェントが適切なテスト項目を作成しやすくなる
- ただし、優先度は低い（既に参照ドキュメントが存在するため）

---

## 5. 改善後の予測効果

### 改善前（現状）
**QA計画可能性スコア: 60/100**

| 評価項目 | スコア | 理由 |
|---------|-------|------|
| 自動テスト実行 | 20/20 | 完全に計画可能 |
| テスト評価基準 | 15/15 | 明確に定義されている |
| 受け入れ条件の参照 | 5/25 | 所在が不明確 |
| ドキュメント構造 | 5/20 | 未定義 |
| Issue形式 | 5/10 | 未定義 |
| QA仕様書フロー | 5/5 | 軽度の不明確さ |
| レビューガイドライン | 3/5 | 未作成 |
| テスト項目例 | 2/0 | 参照ドキュメント存在（加点） |
| **合計** | **60/100** | |

### 改善後（優先度1-2を実施）
**QA計画可能性スコア: 90/100**

| 評価項目 | スコア | 理由 |
|---------|-------|------|
| 自動テスト実行 | 20/20 | 完全に計画可能 |
| テスト評価基準 | 15/15 | 明確に定義されている |
| 受け入れ条件の参照 | 23/25 | requirements.mdテンプレートで明確化 |
| ドキュメント構造 | 18/20 | テンプレート作成で標準化 |
| Issue形式 | 5/10 | 未対応（優先度3） |
| QA仕様書フロー | 5/5 | 軽度の不明確さ |
| レビューガイドライン | 3/5 | 未対応（優先度5） |
| テスト項目例 | 2/0 | 参照ドキュメント存在（加点） |
| **合計** | **90/100** | |

### 改善後（優先度1-6をすべて実施）
**QA計画可能性スコア: 98/100**

| 評価項目 | スコア | 理由 |
|---------|-------|------|
| 自動テスト実行 | 20/20 | 完全に計画可能 |
| テスト評価基準 | 15/15 | 明確に定義されている |
| 受け入れ条件の参照 | 25/25 | 完全に明確化 |
| ドキュメント構造 | 20/20 | 完全に標準化 |
| Issue形式 | 10/10 | テンプレート作成で標準化 |
| QA仕様書フロー | 5/5 | 完全に明確化 |
| レビューガイドライン | 5/5 | 作成完了 |
| テスト項目例 | 2/0 | プロンプト内に具体例追加（加点） |
| **合計** | **98/100** | |

---

## 6. 結論

### 現状の評価
`/task-exec` カスタムプロンプトは、**自動テスト（pnpm test/lint/build/typecheck）の実行と判定については完全に計画可能**です。しかし、**QAの中核業務である「受け入れ条件に基づく動作確認テスト」については計画不能**です。

### 主要な問題
**受け入れ条件の所在が不明確**であることが最大の問題です。QAエージェントは「受け入れ条件に基づく徹底的なテスト」を実施することが期待されていますが、受け入れ条件がどこに記載されているかが明示されていないため、テストシナリオを設計できません。

### 推奨される対応
**優先度1（最重要）**: requirements.md テンプレートの作成と、受け入れ条件の明確化
**優先度2（重要）**: ドキュメント構造の標準化

これらを実施することで、**QA計画可能性スコアが 60点 → 90点 に向上**し、QAエージェントが効果的に動作確認テストを設計・実施できるようになります。

### 改善後の予測
すべての推奨事項を実施することで、QA計画可能性スコアは **98/100** に達し、`/task-exec` コマンドは**完全に自動化された高品質な開発ワークフロー**を実現できます。

---

**評価完了日**: 2025-11-22
**次のアクション**: 優先度1-2の対応を実施し、requirements.mdテンプレートとドキュメント構造の標準化を完了させる
