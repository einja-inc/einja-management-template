# 品質と運用

## エラーハンドリング

### エラー分類とコード体系

すべてのエラーは`SyncError`クラスを継承し、エラーコードとカテゴリで分類されます。

**ErrorCategory**:
- `VALIDATION`: バリデーションエラー
- `FILE_SYSTEM`: ファイルシステムエラー
- `MERGE`: マージエラー
- `METADATA`: メタデータエラー
- `NETWORK`: ネットワークエラー（将来対応）

### エラーコード一覧

| コード | カテゴリ | 説明 | 復旧可能性 | 対処方法 |
|-------|---------|------|-----------|---------|
| INVALID_CATEGORY | VALIDATION | 無効なカテゴリ指定 | ✅ | 有効なカテゴリを提示 |
| MARKER_UNPAIRED_START | VALIDATION | 対応する@einja:managed:endがない | ✅ | ファイルパスと行番号を表示 |
| MARKER_UNPAIRED_END | VALIDATION | 対応する@einja:managed:startがない | ✅ | ファイルパスと行番号を表示 |
| MARKER_NESTED | VALIDATION | マーカーのネスト検出 | ✅ | ネスト箇所を表示 |
| FILE_NOT_FOUND | FILE_SYSTEM | ファイルが存在しない | ✅ | スキップして続行 |
| FILE_READ_ERROR | FILE_SYSTEM | ファイル読み込み失敗 | ⚠️ | 権限確認を促す |
| FILE_WRITE_ERROR | FILE_SYSTEM | ファイル書き込み失敗 | ⚠️ | 権限確認を促す |
| MERGE_CONFLICT | MERGE | マージコンフリクト | ✅ | コンフリクトマーカー挿入 |
| METADATA_INVALID | METADATA | メタデータ形式不正 | ✅ | 再初期化を提案 |
| METADATA_VERSION_MISMATCH | METADATA | バージョン不一致 | ✅ | マイグレーション実行 |
| UNRESOLVED_CONFLICTS | MERGE | 未解決のコンフリクトあり | ✅ | 解消方法を案内 |

### エラー処理戦略

#### 1. バリデーションエラー

**戦略**: エラー内容を明確に表示し、修正方法を提案

- マーカー検証エラー時はファイルパスと行番号を表示
- 修正手順を段階的に案内
- エラー後の処理継続可否を判断

#### 2. ファイルシステムエラー

**戦略**: 権限エラーは即座に中断、その他はスキップして続行

**エラー種別ごとの処理**:

| エラーコード | 処理内容 | 継続可否 |
|-------------|---------|---------|
| ENOENT（ファイル不存在） | 警告ログ出力、スキップ | ✅ 続行 |
| EACCES（権限エラー） | エラー表示、即座に中断 | ❌ 中断 |
| その他 | エラーログ出力、スキップ | ✅ 続行 |

#### 3. マージコンフリクト

**戦略**: コンフリクトマーカーを挿入し、解消方法を案内

**処理フロー**:
1. コンフリクト検出
2. コンフリクトマーカー挿入
3. ファイルに書き込み
4. コンフリクト情報を記録
5. 処理続行（他のファイルも処理）
6. 最後にコンフリクト一覧を表示

#### 4. メタデータエラー

**戦略**: バージョン不一致は自動マイグレーション、破損は再初期化

**メタデータ状態別の処理**:

| 状態 | 処理内容 |
|------|---------|
| 存在しない | 初期メタデータを作成 |
| バージョン不一致 | 自動マイグレーション実行 |
| スキーマ不正 | 再初期化を提案（ユーザー確認） |

### リトライ戦略

一時的なエラー（ネットワーク、ファイルロック）に対してはリトライを実施します。

**リトライ設定**:
- 最大リトライ回数: 3回
- リトライ間隔: 指数バックオフ（1秒、2秒、4秒）
- リトライ対象: `NETWORK`カテゴリのエラーのみ

## セキュリティ考慮事項

### ファイルパストラバーサル攻撃の防止

**対策内容**:
1. パス解決時にbaseDir外へのアクセスを禁止
2. `../`を含むパスを拒否
3. 絶対パスと正規化パスの比較で検証

**検証ロジック**:
- `path.resolve()`でパスを正規化
- `startsWith()`でbaseDir配下かチェック
- 違反時は即座に`INVALID_PATH`エラーを投げる

### シンボリックリンクの追跡制限

**対策内容**:
- シンボリックリンクは同期対象外
- `fs.lstat()`でシンボリックリンクを検出
- 検出時は`SYMLINK_NOT_ALLOWED`エラーを投げる

**理由**: シンボリックリンクの追跡は意図しないファイル操作やセキュリティリスクに繋がるため

### 実行権限の保持

**対策内容**:
- ファイル書き込み前に既存ファイルの権限を取得
- 書き込み後に権限を復元
- 実行可能ファイルの権限を保持

## パフォーマンス最適化

### ファイルハッシュキャッシュ

**目的**: 同一ファイルの重複ハッシュ計算を避ける

**実装方針**:
- `Map<string, string>`でキャッシュ
- キャッシュキー: `${filePath}:${content.length}`
- ハッシュアルゴリズム: SHA-256

**効果**: 同一ファイルの2回目以降のハッシュ計算をスキップ

### 並列処理によるファイル処理

**目的**: 複数ファイルの同期処理を並列化して高速化

**実装方針**:
- バッチサイズ: 10ファイル
- `Promise.all()`で並列処理
- バッチごとに順次処理（メモリ使用量の制限）

**効果**: 100ファイルの同期を3秒以内に完了

### 差分計算の最適化

**目的**: ファイル内容が同一の場合はマージ処理をスキップ

**スキップ条件**:

| 条件 | 処理 |
|------|------|
| ローカルHash = テンプレートHash = ベースHash | スキップ（変更なし） |
| ローカルHash = テンプレートHash ≠ ベースHash | スキップ（両者が同じ変更） |
| 上記以外 | マージ処理実行 |

## テスト設計

### 単体テスト

#### 正常系テストケース

**1. MetadataManager - メタデータ読み込み**
- **Given**: 有効な`.einja-sync.json`が存在する
- **When**: `load()`メソッドを実行する
- **Then**: 正しくパースされたSyncMetadataオブジェクトが返される

**2. FileFilter - 同期対象スキャン**
- **Given**: `.claude/commands/einja/`に3ファイル、`_custom.md`が1ファイル存在
- **When**: `scanSyncTargets()`を実行する
- **Then**: `_custom.md`を除く3ファイルがリストアップされる

**3. DiffEngine - 3方向マージ（ローカルのみ変更）**
- **Given**: ベース版とテンプレート版が同一、ローカル版のみ異なる
- **When**: `merge3Way()`を実行する
- **Then**: ローカル版の変更が採用され、コンフリクトなし

**4. MarkerProcessor - マーカーパース**
- **Given**: 正しくペアになった`@einja:managed`マーカーを含むファイル
- **When**: `parseMarkers()`を実行する
- **Then**: managedとunmanagedセクションが正しく分離される

**5. HashCache - ハッシュキャッシュ**
- **Given**: 同一ファイルパスと内容で2回ハッシュ取得
- **When**: `getHash()`を2回実行する
- **Then**: 2回目はキャッシュから取得され、計算処理がスキップされる

#### 異常系テストケース

**1. MetadataManager - 不正なJSON**
- **Given**: 破損した`.einja-sync.json`が存在する
- **When**: `load()`を実行する
- **Then**: `METADATA_INVALID`エラーが投げられ、再初期化が提案される

**2. FileFilter - 無効なカテゴリ指定**
- **Given**: `--only invalid-category`オプション
- **When**: `filterByCategories()`を実行する
- **Then**: `INVALID_CATEGORY`エラーが投げられ、有効なカテゴリ一覧が表示される

**3. DiffEngine - マージコンフリクト**
- **Given**: ローカルとテンプレートで同じ行を異なる内容で変更
- **When**: `merge3Way()`を実行する
- **Then**: コンフリクトマーカーが挿入され、`MERGE_CONFLICT`ステータスが返される

**4. MarkerProcessor - 対応しないstartマーカー**
- **Given**: `@einja:managed:start`のみ存在し、`end`がない
- **When**: `validateMarkers()`を実行する
- **Then**: `MARKER_UNPAIRED_START`エラーが返され、行番号が表示される

**5. SyncCommand - 未解決のコンフリクトが存在**
- **Given**: コンフリクトマーカーを含むファイルが存在
- **When**: 再度`sync`コマンドを実行する
- **Then**: `UNRESOLVED_CONFLICTS`エラーが表示され、同期処理がスキップされる

### 統合テスト

**1. 完全な同期フロー**
- **Given**: 新規プロジェクトで初回同期
- **When**: `npx @einja/cli sync`を実行
- **Then**: 全ファイルがテンプレートからコピーされ、`.einja-sync.json`が生成される

**2. 選択的同期フロー**
- **Given**: `--only commands,agents`オプション指定
- **When**: `sync`コマンドを実行
- **Then**: commandsとagentsのみ同期され、skillsとdocsはスキップされる

**3. ドライランフロー**
- **Given**: `--dry-run`オプション指定
- **When**: `sync`コマンドを実行
- **Then**: ファイル変更は行われず、差分サマリーのみ表示される

**4. 強制上書きフロー**
- **Given**: ローカル変更があるファイルに対して`--force`オプション指定
- **When**: `sync`コマンドを実行
- **Then**: ローカル変更が破棄され、テンプレート版で上書きされる

### E2Eテスト

**1. 継続的な同期シナリオ**
- **Given**: 既存プロジェクトで過去に同期済み
- **When**: テンプレートが更新され、再度`sync`を実行
- **Then**: ローカルのカスタマイズを保持しつつ、テンプレート更新が適用される

**2. コンフリクト解消シナリオ**
- **Given**: マージコンフリクトが発生した状態
- **When**: ユーザーがコンフリクトマーカーを手動編集して解消
- **Then**: 再度`sync`を実行すると、解消済みファイルが検証され、同期が完了する

**3. パッケージ名変更シナリオ**
- **Given**: `@einja/claude-cli`から`@einja/cli`への移行期間
- **When**: `npx @einja/claude-cli sync`を実行
- **Then**: 非推奨警告が表示され、`@einja/cli`の使用を促される

## マイグレーション戦略

### メタデータフォーマットのバージョン管理

メタデータのバージョンが変更された場合、自動マイグレーションを実施します。

**マイグレーション対象**:

| 旧バージョン | 新バージョン | 変更内容 |
|------------|------------|---------|
| 0.1.0 | 0.2.0 | `templateVersion`, `FileMetadata.syncedAt`, `FileMetadata.conflicts`を追加 |

**マイグレーションフロー**:
1. 旧フォーマット検出
2. マイグレーション開始メッセージ表示
3. 新フォーマットへのデータ変換
4. メタデータ保存
5. 完了メッセージ表示

### バックアップとロールバック

同期処理実行前に自動バックアップを作成します。

**バックアップ仕様**:
- バックアップ命名: `{targetDir}.backup-{timestamp}`
- タイムスタンプ形式: ISO 8601（コロン・ドット除去）
- 除外対象: `.git`, `node_modules`

**ロールバック機能（将来実装）**:
- バックアップからの復元コマンド
- 複数バックアップからの選択機能
- ロールバック前の確認プロンプト

## モニタリングと分析

本機能はCLIツールのため、リアルタイムモニタリングは実施しません。ただし、実行ログと統計情報を記録します。

### 実行ログの記録

**ログ内容**:
- タイムスタンプ
- 実行コマンドとオプション
- 同期結果（成功/失敗ファイル数）
- 処理時間
- エラー情報

**ログ形式**: JSON形式（`.einja-logs/sync-{timestamp}.json`）

### 統計情報の集計

**統計項目**:

| 項目 | 説明 |
|------|------|
| totalFiles | 処理対象ファイル数 |
| changedFiles | 変更があったファイル数 |
| succeededFiles | 成功したファイル数 |
| conflictFiles | コンフリクトが発生したファイル数 |
| skippedFiles | スキップしたファイル数 |
| duration | 処理時間（ミリ秒） |

## 実装上の注意点

### コード品質とセキュリティ

- **TypeScript strict mode準拠**: すべてのコードは`strict: true`で型チェック
- **any型の使用禁止**: 型定義が不明な場合は`unknown`を使用し、型ガードで絞り込む
- **入力値の検証**: ファイルパス、オプション値は必ずバリデーションを実施
- **エラーメッセージのサニタイゼーション**: ユーザー入力をエラーメッセージに含める際はエスケープ処理

### パフォーマンスとスケーラビリティ

- **並列処理の制限**: 同時処理数を10ファイルに制限し、メモリ使用量を抑制
- **大容量ファイルの処理**: 1MB以上のファイルはストリーム処理を検討
- **ハッシュキャッシュの活用**: 同一ファイルの重複ハッシュ計算を回避
- **パフォーマンステスト**: 100ファイルの同期が3秒以内に完了することを検証

### 保守性と拡張性

- **モジュール分離**: 各機能（メタデータ管理、マージ、マーカー処理）を独立したモジュールに分離
- **設定のカスタマイズ**: 除外パターン、マーカー構文などは設定ファイルで変更可能にする
- **ログの構造化**: ログはJSON形式で出力し、分析や監視を容易にする
- **テストカバレッジ80%以上**: 主要な処理パスは必ずテストでカバー

### エラーハンドリングの原則

- **早期リターン**: 検証エラーは早期にエラーを返し、処理を中断
- **復旧可能なエラー**: コンフリクトなど復旧可能なエラーは処理を続行
- **復旧不可能なエラー**: 権限エラーなど復旧不可能なエラーは即座に中断
- **明確なメッセージ**: エラーメッセージには具体的な原因と対処方法を含める

## まとめ

本設計書で定義した`sync`コマンドは、以下を実現します：

✅ **3方向マージによる安全な同期**: ローカルのカスタマイズを保持しつつテンプレート更新を適用
✅ **@einja:managedマーカー**: 特定セクションをCLIが完全管理
✅ **選択的同期**: 必要なカテゴリのみを更新
✅ **ドライラン機能**: 変更前に差分を確認
✅ **コンフリクト検出と報告**: 手動解決が必要な箇所を明確に提示
✅ **パフォーマンス要件達成**: 100ファイルの同期を3秒以内に完了
✅ **型安全な実装**: TypeScript strict mode準拠、any型禁止

すべての開発者は、この設計に従って実装を行ってください。
