# コミットルール

## 重要：コミット分割ルールの厳守について

- コミット分割ルールに違反した場合、重大なレビュープロセス阻害・履歴管理上の問題となるため、**絶対に違反しないこと**
- 万一違反が発生した場合は、必ず即座に報告し、再発防止策（作業前の分割計画明示・コミット粒度の事前確認など）を徹底すること
- 「まとめコミット」「複数目的の混在コミット」「コミット粒度の過剰肥大化」は**厳禁**
- このルールは全開発者・AIアシスタントが例外なく厳守すること

## コミットの流れ

1. **コミット前の確認**
   - コードがコンパイルできる状態か
   - テストが通る状態か
   - 不要なデバッグコードやコメントが残っていないか

2. **最新化**
   ```bash
   git pull --rebase
   ```

3. **現在の状態確認**
   ```bash
   git status
   ```

4. **コミット分割方針の策定**
   - 差分を「コミットの分割方針」に応じて分割
   - 具体的なコミット分割とその内容、コミットメッセージの合意を取る
   - 分割された各コミットの内容は「コミット内容の確認事項」に留意

5. **コミットの実行**
   - 合意したコミット方針でコミットを行う

6. **プッシュ前の品質チェック（必須）**
   ```bash
   pnpm prepush
   ```
   - リント、型チェック、テストを一括実行
   - エラーがある場合は修正してから再度実行

7. **プッシュ**
   ```bash
   git push
   ```

## コミットの分割方針

以下の場合は**必ず別々のコミットに分割**してください：

### 1. 異なる目的や種類の変更
- ソースコードの変更とドキュメントの更新
- 機能追加と設定ファイルの変更
- リファクタリングとバグ修正

### 2. 異なるコンポーネントやモジュールの変更
- 複数のマイクロサービスやコンポーネントの変更
- フロントエンドとバックエンドの変更
- インフラ構成とアプリケーションコードの変更

### 3. レビューの容易さを考慮した分割
- 大規模な変更は小さな論理的なまとまりに分割
- 設定変更とその設定を使用するコードの変更は分割
- テストコードの追加・更新は実装とは別のコミット

## コミット分割の具体例

以下のような変更がある場合の分割例：

### 1. 構造的な変更
```bash
git commit -m "refactor: ディレクトリ構造の整理

- 関連するファイルを適切なディレクトリに移動
- 不要なファイルの削除
- ファイル名の統一"
```

### 2. 実装の修正
```bash
git commit -m "fix: 実装の修正

- バグの修正内容
- 影響範囲
- 修正理由"
```

### 3. テストの追加
```bash
git commit -m "test: テストの追加

- 追加したテストの概要
- テストでカバーする機能や条件
- 既存テストの修正点"
```

### 4. 設定の更新
```bash
git commit -m "chore: 設定ファイルの更新

- 更新した設定項目
- 更新理由
- 影響範囲"
```

### 5. ドキュメントの追加
```bash
git commit -m "docs: ドキュメントの追加

- 追加したドキュメントの概要
- 主な内容
- 参照すべき関連ドキュメント"
```

## コミットメッセージの形式

### 基本形式
- プレフィックス: タイプを示す短い識別子
- 日本語で記述
- 1行目に概要、2行目以降に詳細を記述

### プレフィックスの使い分け

| プレフィックス | 用途 | 例 |
|--------------|------|-----|
| `feat:` | 新機能の追加 | `feat: ユーザー認証機能の追加` |
| `fix:` | バグ修正 | `fix: ログイン時のエラー修正` |
| `docs:` | ドキュメントの更新 | `docs: APIドキュメントの追加` |
| `style:` | コードスタイルの修正 | `style: フォーマットの統一` |
| `refactor:` | リファクタリング | `refactor: 認証処理の共通化` |
| `test:` | テストの追加・修正 | `test: ユニットテストの追加` |
| `chore:` | ビルドプロセスやツールの変更 | `chore: 依存パッケージの更新` |

### 良いコミットメッセージの例

```bash
feat: ユーザー認証機能の追加

- JWT認証の実装
- ログイン・ログアウトエンドポイントの追加
- 認証ミドルウェアの実装
- テストケースの追加

影響範囲：
- /auth/*エンドポイント
- ミドルウェア
- ユーザーモデル
```

### 悪いコミットメッセージの例

```bash
update files  # 変更内容が不明確

fix some bugs  # 具体的な修正内容が不明

various changes  # 変更の種類や目的が不明確
```

## コミットの粒度と単位

- **1つのコミットは1つの論理的な変更のみ**を含める
- 機能追加やバグ修正は1つずつコミット
- リファクタリングは機能変更と分けてコミット
- 複数のファイルを変更する場合も、関連する変更は1つのコミットにまとめる
- **1つのコミットの変更量は、レビューしやすい程度（100行程度）に抑える**
- **コミット粒度の過剰肥大化・まとめコミットは禁止**

## コミットのタイミング

- 機能の実装が完了した時点でコミット
- テストが通る状態でコミット
- 1日の作業終了時には必ずコミット
- 他の開発者と共有する前にコミット
- 大きな変更は小分けにしてコミット
- **コミットタイミングの逸脱やまとめコミットは禁止**

## コミット内容の確認事項

- 変更内容がコミットメッセージと一致しているか
- 適切な粒度で分割されているか
- 関連する変更が漏れなくコミットされているか

## プッシュ前の必須確認

**動作確認を必ず実行**: APIならcurl確認、スクリプトなら実行確認、画面ならMCPでブラウザ確認

**重要**: プッシュ前には必ず `pnpm prepush` を実行してください。このコマンドは以下のチェックを行います：

1. **コードフォーマット**: Biomeによる自動フォーマット
2. **リントチェック**: コード品質の確認
3. **型チェック**: TypeScriptの型エラーがないか確認
4. **テスト実行**: 全てのテストが通ることを確認

```bash
# プッシュ前の必須コマンド
pnpm prepush

# エラーが出た場合は修正して再実行
# 全てのチェックが通ってからプッシュ
git push
```

**注意**: `pnpm prepush` を実行せずにプッシュしてCIで失敗した場合、履歴が汚れるため必ず事前実行すること。

## ブランチ戦略

| ブランチ | 用途 |
|---------|------|
| `main` | 本番環境用 |
| `develop` | 開発環境用 |
| `feature/*` | 機能開発用 |
| `hotfix/*` | 緊急修正用 |

## まとめ

コミットルールの遵守は、プロジェクトの履歴管理とレビュープロセスの効率化に直結します。全ての開発者・AIアシスタントは、これらのルールを例外なく厳守してください。
