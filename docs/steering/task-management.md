# タスク管理ガイドライン

このドキュメントでは、プロジェクトのタスク管理における階層構造、GitHub Issue管理、用語定義を説明します。

## タスク管理の方法

このプロジェクトでは**GitHub Issue**を使用してタスクを管理します。

### 基本構造

- **1 spec = 1 GitHub Issue**
- 各specフォルダ（`docs/specs/issues/issue{issue番号}-{機能名}/`）に対して1つのGitHub Issueを作成
- requirements.mdとdesign.mdはファイルとして保持
- タスク一覧のみGitHub Issueで管理

### GitHub Issueの構造

Issue本文には以下のセクションを含みます：

```markdown
## AS-IS
<!-- requirements.mdから抽出した現在の状態・問題点 -->

## TO-BE
<!-- requirements.mdから抽出した実装後の期待する状態 -->

## 対応方針
<!-- design.mdから抽出した技術的アプローチ、使用ライブラリ、実装方針 -->

## タスク一覧

### Phase 1: [フェーズ名]

- [ ] 1.1 [タスクグループ名]

  - 1.1.1 [タスク名]
    - サブタスク内容
    - **要件**: Story X
    - **依存関係**: なし
    - **完了条件**: [テスト条件]が通ること（AC[番号]を満たす）
    - **対応設計**: design.md「[セクション名]」セクション
    - **シナリオテスト**: なし（基盤構築タスク、UIフロー未実装のため）

  - 1.1.2 [タスク名]
    - サブタスク内容
    - **要件**: Story X
    - **依存関係**: 1.1.1
    - **完了条件**: [テスト条件]が通ること（AC[番号]を満たす）
    - **対応設計**: design.md「[セクション名]」セクション
    - **シナリオテスト**: シナリオ1 Step 1-3（部分実行）

- [ ] 1.2 [タスクグループ名]

  - 1.2.1 [タスク名]
    - サブタスク内容
    - **要件**: Story X
    - **依存関係**: 1.1
    - **完了条件**: ...
    - **対応設計**: design.md「[セクション名]」セクション
    - **シナリオテスト**: シナリオ2 Step 1-5

### Phase 2: [フェーズ名]

- [ ] 2.1 [タスクグループ名]

  - 2.1.1 [タスク名]
    - サブタスク内容
    - **要件**: Story X
    - **依存関係**: Phase 1完了
    - **完了条件**: ...
    - **対応設計**: design.md「[セクション名]」セクション
    - **シナリオテスト**: シナリオ3 全ステップ
```

### タスクグループのステータス管理

GitHub Issueのチェックボックスでタスクグループのステータスを管理します：

**未着手**:
```markdown
- [ ] 1.1 タスクグループ名
```

**完了**（チェックボックスをON）:
```markdown
- [x] 1.1 タスクグループ名
```

**注意**: タスクグループの完了時、GitHub Issueのチェックボックス更新はユーザーが明示的に指示した場合のみ行います。`/task-exec`コマンドは自動でIssueを更新しません。

### Issueのライフサイクル

1. **Issue作成**: `/spec-create`コマンドで仕様書作成時に自動生成
2. **タスクグループ実行**: `/task-exec #{issue_number} {タスクグループ番号}`でタスクグループを実行
3. **タスクグループ完了**: 実装・テスト・レビュー完了後、チェックボックスをON（手動更新）
4. **Issue完了**: すべてのタスクグループが完了したらIssueをClose

## タスク階層の用語定義

プロジェクトのタスク管理では、以下の4階層を使用します。

### タスク階層一覧表

| 階層 | 番号形式 | 粒度・定義 | 成果物 | Issueでの書式 |
|------|----------|------------|--------|---------------|
| Phase | 1, 2, 3 | 一連のACを確認できる単位（2-3個、全Phase完了で全AC網羅） | リリース | `### Phase 1: [名前]` |
| タスクグループ | X.Y | 1つまたは一部のACが確認できる単位（大きめの1PRでもOK） | 1PR・マージ・デプロイ | `- [ ] 1.1 [名前]` |
| タスク | X.Y.Z | コミット単位（15分〜1時間程度） | 個別コミット | `  - 1.1.1 [名前]` + メタデータ |
| サブタスク | なし | タスク内の詳細作業（任意） | タスクの一部 | `    - [内容]`（任意） |

### Phase完了確認タスクグループ

各Phaseの最後には、必ず**Phase完了確認**タスクグループを配置します：

```markdown
## Phase 1完了確認

- [ ] 1.X フェーズ1完了条件確認

  - 1.X.1 フェーズ1全タスク完了確認
    - タスクグループ1.1〜1.N の全タスク完了確認
    - 全シナリオテストの成功確認
    - コードレビュー完了確認
    - デプロイ可能な状態であることを確認
    - **要件**: Story 1, Story 2（該当する全Story）
    - **依存関係**: 1.N.Z（Phase内の最後のタスク番号）
    - **完了条件**: フェーズ1の全タスクグループが完了し、受け入れ基準**AC1.1〜AC1.N**を満たすことが確認できること
    - **対応設計**: design.md 全セクション
    - **シナリオテスト**: 全シナリオ（リグレッション確認）
```

**目的**:
- Phase内の全タスクが完了していることを明示的に確認
- 次Phaseへの移行条件を完了条件に明記
- QAチェックポイントとして機能

### 粒度の判断基準

| 階層 | ✅ 適切 | ❌ 不適切 |
|------|---------|----------|
| **Phase** | 2-3個で全AC網羅、機能的区切りで分割 | 4個以上、細かすぎる分割 |
| **タスクグループ** | 縦切り（フルスタック）、AC検証可能、1PR単位 | 横切り（画面/レイヤー/クラス単位）、設定1個だけ |
| **タスク** | 1コミット単位、具体的な作業 | 曖昧な作業、複数日かかる作業 |

### 🔴 ATDDタスクグループ設計原則

**タスクグループ = ACを検証可能にする単位**

ATDDの本質は「受け入れ基準（AC）を中心にタスクを分解する」こと。
タスクグループ完了時に、対応するACがデプロイして検証可能な状態になっていなければならない。

**原則: 縦切り（フルスタック）で分割、横切り（レイヤー/画面）は❌**

✅ **縦切り**（1機能をフルスタックで）:
- Domain → Infrastructure → UseCase → API → UI を1タスクグループで
- 完了時にACが検証可能

❌ **横切り**（レイヤー/画面ごと）:
- Domain層の実装 / Infra層の実装 / UseCase実装 / API実装 / UI実装
- 各層単体では検証不可能

### ❌ アンチパターン（絶対にやってはいけない分割）

**パターン1: 画面ごとの分割**
```
❌ NG例:
- 3.2 一覧画面の実装
- 3.3 詳細画面の実装
- 3.4 新規登録画面の実装
- 3.5 編集画面の実装
- 3.6 削除機能の実装

✅ OK例:
- 2.2 CRUD機能の実装（一覧・詳細・作成・編集・削除）
```

**パターン2: レイヤーごとの分割**
```
❌ NG例:
- 2.1 Domain層の実装（Entity, VO, Repository IF）
- 2.2 Infrastructure層の実装（Mapper, Repository）
- 2.3 Application層の実装（UseCase）
- 2.4 Presentation層の実装（API, UI）

✅ OK例:
- 2.1 招待・パスワード設定機能
  - Domain〜UIまでフルスタックで実装
  - AC3〜AC5を検証可能
```

**パターン3: クラスごとの分割**
```
❌ NG例（これらはタスクグループではなくタスクレベル（X.Y.Z）であるべき）:
- 2.1 User Entityの実装
- 2.2 Invitation Entityの実装
- 2.3 HashedPassword VOの実装
```

### メタデータの記述（タスク単位に付与）

各タスク（X.Y.Z）には以下のメタデータを**必須**で付与します：

```markdown
- [ ] 1.1 Server Core構築とDB設定

  - 1.1.1 packages/server-core初期化とtsconfig設定
    - tsconfig.jsonの設定
    - 依存パッケージのインストール
    - **要件**: Story 1
    - **依存関係**: なし
    - **完了条件**: server-coreパッケージが初期化されること（AC1.1を満たす）
    - **対応設計**: design.md「Server Core構築」セクション
    - **シナリオテスト**: なし（基盤構築タスク、UIフロー未実装のため）

  - 1.1.2 DB接続設定とマイグレーション
    - Prismaスキーマの作成
    - マイグレーションの実行
    - **要件**: Story 1
    - **依存関係**: 1.1.1
    - **完了条件**: DBに接続できること（AC1.2〜AC1.3を満たす）
    - **対応設計**: design.md「DB設計」セクション
    - **シナリオテスト**: なし（DB設定のみ、UIフロー未実装のため）
```

**メタデータ項目（全て必須）**:
- **要件**: 対応するStory番号
- **依存関係**: なし / X.Y.Z / Phase X完了
- **完了条件**: AC番号を含む完了条件
- **対応設計**: design.mdの参照セクション
- **シナリオテスト**: 該当タスク完了時に実行するシナリオ（該当なければ「なし」と理由を明記）

**注意**: サブタスクは**任意**で記載。詳細はrequirements.md/design.mdを参照。

### 依存関係の記述形式（重要）

**🔴 `pnpm task:loop`スクリプトが認識できる形式のみ使用すること**

| 記述形式 | 意味 | 例 |
|---------|------|-----|
| `なし` | 依存関係なし | `**依存関係**: なし` |
| `X.Y` | タスクグループ依存 | `**依存関係**: 1.1` |
| `X.Y, X.Y` | 複数タスクグループ依存 | `**依存関係**: 1.2, 1.3` |
| `Phase X完了` | Phase依存 | `**依存関係**: Phase 1完了` |

**❌ 使用禁止の形式:**
- `1.1完了` → スクリプトが認識できない
- `タスク1.1` → スクリプトが認識できない
- `1.1、1.2` → 全角カンマは避ける（半角カンマ推奨）

## タスク管理のワークフロー

> **詳細なフロー（仕様書作成からレビュー・マージまで）は[開発ワークフロー](development-workflow.md)を参照してください。**

### 1. タスクグループを選定・実行
- `/task-exec #{issue_number} {タスクグループ番号}`コマンドを実行
- タスクグループ番号は必須引数（例: `1.1`, `2.3`）
- executer → reviewer → qa の3段階で実行

### 2. タスクを順次実装し、コミット
- 各タスク（1.1.1, 1.1.2...）完了ごとにコミット
- コミットメッセージにタスク内容を記載
- 例: `feat(server-core): packages/server-core初期化とtsconfig設定`
- コミットルールは[コミットルール](commit-rules.md)を参照

### 3. タスクグループ完了時にPR作成
- 全タスクが完了したらPR作成
- PR単位でレビュー・デプロイ・QA実施
- PRタイトル: `[タスクグループ番号] タスクグループ名`（例: `[1.1] Server Core構築とDB設定`）

### 4. Issue更新（手動）
- タスクグループ完了後、GitHub Issueのチェックボックスを手動でON
- または、ユーザーが明示的に指示した場合のみ自動更新
- すべてのタスクグループが完了したら、IssueをClose

## Vibe-Kanbanタスク作成時の必須情報

### タスクタイトル形式
```
[タスクグループ番号] タスクグループ名
```

**例**: `[1.1] Server Core構築とDB設定`

### タスク説明形式

```markdown
## GitHub Issue
#{issue_number}

## タスクグループ番号
<タスクグループ番号>

## 概要
<タスクグループの概要>

## タスク
<GitHub Issueから抽出したタスク一覧>

## 依存関係
<依存するタスクグループ番号>

## 完了条件
<受け入れ基準を含む完了条件>

## 対応設計
<design.mdの参照箇所>
```

**例**:
```markdown
## GitHub Issue
#17

## タスクグループ番号
1.1

## 概要
packages/server-coreの初期化からDB接続設定まで、Server Coreの基盤構築を完了

## タスク
- 1.1.1 packages/server-core初期化とtsconfig設定
- 1.1.2 DB接続設定とマイグレーション

## 依存関係
なし

## 完了条件
server-coreパッケージが動作し、DBに接続できること（AC1.1を満たす）

## 対応設計
design.md「Server Core構築」セクション
```

## コマンドリファレンス

### タスク管理関連コマンド

**仕様書作成とIssue生成**:
```bash
/spec-create [タスク内容の説明]
```
- requirements.md、design.mdを作成し、GitHub Issueを自動生成

**タスクグループ実行**:
```bash
/task-exec #{issue_number} {タスクグループ番号}
```
- Issue番号とタスクグループ番号は両方必須
- executer → reviewer → qa の3段階で実行
- QA合格後は追加指示待ち状態に入る
- GitHub Issue更新はユーザーの明示的指示時のみ

**自動ループ実行（TypeScriptスクリプト）**:
```bash
pnpm task:loop <issue番号>
pnpm task:loop <issue番号> --max <番号>     # 指定番号まで実行
pnpm task:loop <issue番号> --base <ブランチ>  # ベースブランチ指定
```
- 着手可能なタスクグループを並列でVibe-Kanbanに登録
- Done状態を監視して次のタスクを自動開始

**仕様書からドキュメント更新**:
```bash
/update-docs-by-task-specs [タスク仕様書ディレクトリパス]
```
- タスク仕様書の内容をfeature仕様書とsteering仕様書に反映
