# 価値あるテストを生む要件定義とテスト設計ガイド

## 1. 受け入れ基準の原則

### Do
- 振る舞い・入力・観測可能な結果をセットで書く（Given/When/Then または 条件/操作/期待結果）。
- ビジネス価値やユーザー影響が分かる文脈を添える（誰が何のために使うか）。
- 正常系に加え、代表的な異常・境界ケースを列挙する。
- 観測手段（API レスポンス、イベント、DB 状態など）を明示する。
- 実装と無関係な用語で書き、内部構造への言及は避ける。

### Don't
- 「ファイルが存在する」「〇〇を返すクラスがある」など構造・命名のみを確認させる。
- 単一の肯定文で完結させて振る舞いの条件や観測結果を書かない。
- テストレベルを曖昧にし、誰がどの観点で検証するか不明瞭にする。
- 期待結果を「問題ないこと」「成功すること」で済ませる。
- 実装手段（特定フレームワーク、DB テーブル構造など）を強制する。

### 振る舞い駆動テンプレート
```
ACx.y: <振る舞いの名前>
- 前提: <状態/入力/役割>
- 操作: <ユーザー操作 or システムイベント>
- 期待結果: <観測可能なアウトプット>（例: HTTP ステータス/レスポンス/DB 変化/イベント）
- 検証レベル: <Unit | Integration | E2E>（複数可）
- 補足: <ビジネスルールやエッジケース>
```

## 2. テスト設計の原則

### テストレベルと責務
- **単体 (Unit)**: 単一モジュールの意思決定ロジックを高速に検証。外部依存はモック化し、条件分岐とエッジケース網羅。
- **統合 (Integration)**: 境界（Repository+DB, UseCase+Gateway, API+Middleware など）越しの契約を検証。実際のインフラ接続や本物に近いセットアップを使い、主要なハッピーパス＋代表的な異常系を確認。
- **E2E**: ユーザー視点で最終価値を確認。シナリオは少数に絞り、クリティカルパスと主要なバックオフ/ロールバック挙動を検証。

### 価値あるテスト判定基準
- 仮説: テストが守るべきビジネスルールや SLA が明文化されている。
- 分離: 振る舞い単位の原因→結果を説明できる。
- 再現性: 決定論的で、入力と期待結果から誰でも同じ結論を得られる。
- 監視性: 失敗時に「何が壊れたか」がメッセージやログから分かる。
- 保守性: 実装ディテールではなく契約・振る舞いに結び付いているため、内部構造変更で安易に壊れない。
- コスト対価: 実行時間/セットアップコストに見合うリスク低減効果がある。

## 3. 具体例集

### ケース1: データベース層（Repository）
- 悪い例: 「UserRepository が実装されている」
- 良い例:
  ```
  AC1.1: UserRepository はメールアドレス重複を防ぐ
  - 前提: 同一メールを持つユーザーが既に存在
  - 操作: create({email}) を呼ぶ
  - 期待結果: Result.Err(DuplicateEmail) を返し、DB 状態は変化しない
  - 検証レベル: Integration（実 DB or Testcontainer）
  ```

### ケース2: アプリケーション層（UseCase）
- 悪い例: 「UseCase がオブジェクトリテラル形式で定義されている」
- 良い例:
  ```
  AC2.2: PasswordResetUseCase はトークン発行後にメール送信イベントを発火
  - 前提: 対象ユーザーが存在し、メール送信サービスが利用可
  - 操作: execute({userId})
  - 期待結果:
      1. TokenRepository に 1 件レコード生成
      2. DomainEventBus へ PasswordResetRequested を publish
  - 検証レベル: Unit（メール送信はモック）、Integration（イベントバス接続）
  ```

### ケース3: API 層（REST）
- 悪い例: 「API エンドポイントが定義されている」
- 良い例:
  ```
  AC3.4: GET /users/:id は権限エラーを 403 で返す
  - 前提: 認証済みユーザー A がユーザー B を参照しようとする
  - 操作: GET /users/B
  - 期待結果: HTTP 403, body {"code":"FORBIDDEN","message":"..."}
  - 検証レベル: Integration（API + DB + 認可ミドルウェア）
  ```

### ケース4: バッチ処理（Cron）
- 悪い例: 「job:cleanup スクリプトが存在する」
- 良い例:
  ```
  AC4.3: cleanup ジョブは 30 日以上未使用のセッションを削除
  - 前提: session テーブルに 29 日/30 日/31 日経過データが混在
  - 操作: job:cleanup を実行
  - 期待結果: 31 日 > のレコードのみ削除、削除件数をログ出力
  - 検証レベル: Integration（実 DB）、E2E（ステージングで日次 Cron 監視）
  ```

### ケース5: フロントエンド（画面）
- 悪い例: 「ログイン画面コンポーネントが存在する」
- 良い例:
  ```
  AC5.5: ログインフォームは誤ったパスワードで API エラーを表示
  - 前提: ユーザーが存在、間違った PW を入力
  - 操作: Submit
  - 期待結果:
      1. /api/login が 401 を返すまでスピナー表示
      2. フォーム上に "メールアドレスまたはパスワードが違います" を表示
  - 検証レベル: Unit（フォームバリデーション）、E2E（Playwright で API モック無）
  ```

## 4. QA 仕様書・エージェント指示

### QA 仕様書テンプレート
```
## 機能名
- 背景/価値:
- 関連 AC:
- テスト範囲: <Unit/Integration/E2E>（担当者or自動化）
- シナリオ:
  1. タイトル
     - 前提:
     - 操作:
     - 期待結果:
     - ログ/メトリクス確認方法:
- 非対象（アウトオブスコープ）:
- エビデンス（スクショ/ログ）の保存場所:
```
※ 構造確認チェックは「非対象」に明記し、必要に応じてリントや型チェックに委譲する。

### エージェント指示
- **task-executer**
  - AC で指定された振る舞いをテストで再現しているか確認。
  - 期待結果を実装ではなく外部契約（レスポンス、イベント、DB 状態）に結び付ける。
  - 「構造だけを確認するテスト」は reject（例: `expect(fileExists).toBe(true)` など）。
- **task-qa**
  - テストが失敗したときの診断可能性（メッセージ、ログ）をレビュー。
  - シナリオが AC と 1 対 1 で対応しているか、カバレッジの抜け漏れを指摘。
  - 実行コストに見合う価値が説明されているかをチェックし、価値が示せないテストは差し戻す。

## 5. チェックリスト

### 要件レビュー
- [ ] AC は「条件/操作/期待結果」が揃っているか。
- [ ] 観測可能なアウトプットで確認できるか。
- [ ] ビジネス価値やユーザー影響が説明されているか。
- [ ] ハッピーパスと主要な異常系が含まれているか。
- [ ] テストレベルと責任者が明記されているか。
- [ ] 実装構造への指示（ファイル名/クラス名など）が混入していないか。

### テストレビュー
- [ ] テスト名・説明が AC やビジネスルールを反映しているか。
- [ ] 入力→操作→期待結果が可読な形で記述されているか。
- [ ] 価値のないテスト（構造確認のみ、実装に強く依存）が存在しないか。
- [ ] フェイル時に原因が特定できるアサーション/ログか。
- [ ] 実行コスト（時間/環境構築）が妥当か、冗長なダブりがないか。
- [ ] シナリオのエビデンス（ログ/スクショ）が保存・共有されるか。
